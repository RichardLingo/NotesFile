---
title: 连接接口矩阵互转稀疏矩阵、稠密矩阵
authors: Ethan Lin
year: 2024-12-04
tags:
  - 类型/笔记
  - 日期/2024-12-04
  - 类型/AI问答笔记
  - 内容/算法与数据结构
  - 内容/处理数据
  - 内容/Numpy
  - 内容/PyTorch
  - 内容/稀疏矩阵
  - 内容/连接接口矩阵
  - 内容/PyG
aliases:
  - 连接接口矩阵互转稀疏矩阵、稠密矩阵
---
# 连接接口矩阵互转稀疏矩阵、稠密矩阵


> [!attention]
> 以下由AI回答，不保证正确性！






## 基于 Numpy 的实现

以下是连接接口矩阵 的矩阵与传统稠密矩阵、方法 1 的稀疏矩阵之间的互换函数实现：



### **定义连接接口矩阵 的矩阵**
- 连接接口矩阵 `connections` 是一个 `N × M` 的二维矩阵。
- 行表示 agents，每行存储连接的目标 agent ID（未连接的部分用特殊值，如 `-1` 表示）。




```python


### **1. 连接接口矩阵与传统稠密矩阵的互换**

#### **a) 连接接口矩阵 → 稠密矩阵**

import numpy as np


def method2_to_dense(connections, N):
    """
    将连接接口矩阵 的矩阵转换为传统稠密邻接矩阵。
    :param connections: 连接接口矩阵 的 N × M 矩阵
    :param N: agent 的总数
    :return: 稠密邻接矩阵 (N × N)
    """
    dense_matrix = np.zeros((N, N), dtype=int)  # 初始化稠密矩阵
    for i, row in enumerate(connections):
        for target in row:
            if target != -1:  # 忽略未连接的部分
                dense_matrix[i, target] = 1
    return dense_matrix


#### **b) 稠密矩阵 → 连接接口矩阵**

def dense_to_method2(dense_matrix, M):
    """
    将传统稠密邻接矩阵转换为连接接口矩阵 的矩阵。
    :param dense_matrix: 稠密邻接矩阵 (N × N)
    :param M: 每个 agent 的最大连接数
    :return: 连接接口矩阵 的 N × M 矩阵
    """
    N = dense_matrix.shape[0]
    connections = np.full((N, M), -1, dtype=int)  # 初始化连接接口矩阵 的矩阵
    for i in range(N):
        targets = np.where(dense_matrix[i] > 0)[0]  # 获取第 i 行中所有连接的目标
        if len(targets) > M:
            raise ValueError(f"Agent {i} 的连接数超过了连接接口矩阵的最大连接数 M={M}")
        connections[i, :len(targets)] = targets
    return connections


### **2. 连接接口矩阵与方法 1 的稀疏矩阵的互换**

#### **a) 连接接口矩阵 → 稀疏矩阵**
# 使用稀疏矩阵的 COO 格式（行、列、值的形式）：

from scipy.sparse import coo_matrix


def method2_to_sparse(connections, N):
    """
    将连接接口矩阵 的矩阵转换为稀疏矩阵 (COO 格式)。
    :param connections: 连接接口矩阵 的 N × M 矩阵
    :param N: agent 的总数
    :return: 稀疏矩阵 (COO 格式)
    """
    rows, cols = [], []
    for i, row in enumerate(connections):
        for target in row:
            if target != -1:  # 忽略未连接的部分
                rows.append(i)
                cols.append(target)
    return coo_matrix((np.ones(len(rows)), (rows, cols)), shape=(N, N))


#### **b) 稀疏矩阵 → 连接接口矩阵**
# 从 COO 格式恢复：

def sparse_to_method2(sparse_matrix, M):
    """
    将稀疏矩阵 (COO 格式) 转换为连接接口矩阵 的矩阵。
    :param sparse_matrix: 稀疏矩阵 (COO 格式)
    :param M: 每个 agent 的最大连接数
    :return: 连接接口矩阵 的 N × M 矩阵
    """
    connections = np.full((sparse_matrix.shape[0], M), -1, dtype=int)  # 初始化连接接口矩阵 的矩阵
    row, col = sparse_matrix.nonzero()  # 获取所有非零元素的行列索引
    for i, target in zip(row, col):
        for k in range(M):
            if connections[i, k] == -1:  # 找到第一个空位
                connections[i, k] = target
                break
        else:
            raise ValueError(f"Agent {i} 的连接数超过了连接接口矩阵的最大连接数 M={M}")
    return connections


### **测试示例**


# 测试连接接口矩阵 与稠密矩阵互换
N, M = 5, 3
connections = np.array([[1, 2, -1], [0, -1, -1], [1, 3, 4], [-1, -1, -1], [-1, -1, -1]])
dense_matrix = method2_to_dense(connections, N)
print("稠密矩阵:\n", dense_matrix)
recovered_connections = dense_to_method2(dense_matrix, M)
print("从稠密矩阵恢复的连接接口矩阵:\n", recovered_connections)

# 测试连接接口矩阵 与稀疏矩阵互换
sparse_matrix = method2_to_sparse(connections, N)
print("稀疏矩阵 (COO):\n", sparse_matrix)
recovered_connections_sparse = sparse_to_method2(sparse_matrix, M)
print("从稀疏矩阵恢复的连接接口矩阵:\n", recovered_connections_sparse)


```



### **输出示例**

1. 连接接口矩阵 → 稠密矩阵：
```plaintext
稠密矩阵:
 [[0 1 1 0 0]
  [1 0 0 0 0]
  [0 1 0 1 1]
  [0 0 0 0 0]
  [0 0 0 0 0]]
```

2. 稠密矩阵 → 连接接口矩阵：
```plaintext
从稠密矩阵恢复的连接接口矩阵:
 [[ 1  2 -1]
  [ 0 -1 -1]
  [ 1  3  4]
  [-1 -1 -1]
  [-1 -1 -1]]
```

3. 连接接口矩阵 → 稀疏矩阵（COO 格式）：
```plaintext
稀疏矩阵 (COO):
   (0, 1)	1.0
   (0, 2)	1.0
   (1, 0)	1.0
   (2, 1)	1.0
   (2, 3)	1.0
   (2, 4)	1.0
```

4. 稀疏矩阵 → 连接接口矩阵：
```plaintext
从稀疏矩阵恢复的连接接口矩阵:
 [[ 1  2 -1]
  [ 0 -1 -1]
  [ 1  3  4]
  [-1 -1 -1]
  [-1 -1 -1]]
```

---

这些函数可以在你的稠密、稀疏和连接接口矩阵之间灵活转换。

## 基于 PyTorch 和 PyG 的实现

以下是使用 **PyTorch** 或 **PyTorch Geometric (PyG)** 实现的稠密矩阵、稀疏矩阵和连接接口矩阵之间的互换函数。

---

### **定义说明**
1. **连接接口矩阵**：`connections` 是一个 `N × M` 的矩阵，`-1` 表示未连接。
2. **稠密矩阵**：传统的 `N × N` 邻接矩阵。
3. **稀疏矩阵 (PyG)**：使用 `edge_index` 和 `edge_weight` 表示，其中：
   - `edge_index` 是形状为 `[2, num_edges]` 的张量，记录起点和终点的索引。
   - `edge_weight` 是形状为 `[num_edges]` 的张量，记录每条边的权重。

---

### **1. 连接接口矩阵与稠密矩阵的互换**

#### **a) 连接接口矩阵 → 稠密矩阵**
```python
import torch

def method2_to_dense(connections, N):
    """
    将连接接口矩阵 的矩阵转换为稠密邻接矩阵。
    :param connections: 连接接口矩阵 的 N × M 矩阵 (torch.Tensor)
    :param N: agent 总数
    :return: 稠密邻接矩阵 (N × N)
    """
    dense_matrix = torch.zeros((N, N), dtype=torch.float32)
    for i in range(connections.size(0)):  # 遍历每个 agent
        for target in connections[i]:
            if target != -1:  # 忽略未连接部分
                dense_matrix[i, target] = 1
    return dense_matrix
```

#### **b) 稠密矩阵 → 连接接口矩阵**
```python
def dense_to_method2(dense_matrix, M):
    """
    将稠密邻接矩阵转换为连接接口矩阵 的矩阵。
    :param dense_matrix: 稠密邻接矩阵 (N × N, torch.Tensor)
    :param M: 每个 agent 的最大连接数
    :return: 连接接口矩阵 的 N × M 矩阵 (torch.Tensor)
    """
    N = dense_matrix.size(0)
    connections = torch.full((N, M), -1, dtype=torch.int64)  # 初始化连接接口矩阵
    for i in range(N):
        targets = torch.nonzero(dense_matrix[i] > 0).squeeze(1)  # 获取连接的目标
        if len(targets) > M:
            raise ValueError(f"Agent {i} 的连接数超过了 M={M}")
        connections[i, :len(targets)] = targets
    return connections
```

---

### **2. 连接接口矩阵与稀疏矩阵的互换**

#### **a) 连接接口矩阵 → PyG 稀疏矩阵**
```python
def method2_to_sparse(connections):
    """
    将连接接口矩阵 的矩阵转换为 PyG 的 edge_index 和 edge_weight。
    :param connections: 连接接口矩阵 的 N × M 矩阵 (torch.Tensor)
    :return: edge_index (2 × num_edges), edge_weight (num_edges)
    """
    rows, cols = [], []
    for i in range(connections.size(0)):
        for target in connections[i]:
            if target != -1:
                rows.append(i)
                cols.append(target)
    edge_index = torch.tensor([rows, cols], dtype=torch.int64)
    edge_weight = torch.ones(len(rows), dtype=torch.float32)  # 默认权重为 1
    return edge_index, edge_weight
```

#### **b) PyG 稀疏矩阵 → 连接接口矩阵**
```python
def sparse_to_method2(edge_index, N, M):
    """
    将 PyG 的 edge_index 和 edge_weight 转换为连接接口矩阵 的矩阵。
    :param edge_index: 形状为 (2 × num_edges) 的张量
    :param N: agent 总数
    :param M: 每个 agent 的最大连接数
    :return: 连接接口矩阵 的 N × M 矩阵 (torch.Tensor)
    """
    connections = torch.full((N, M), -1, dtype=torch.int64)
    for i, target in zip(edge_index[0], edge_index[1]):
        for k in range(M):
            if connections[i, k] == -1:  # 找到第一个空位
                connections[i, k] = target
                break
        else:
            raise ValueError(f"Agent {i} 的连接数超过了 M={M}")
    return connections
```

---

### **3. 稠密矩阵与 PyG 稀疏矩阵的互换**

#### **a) 稠密矩阵 → PyG 稀疏矩阵**
```python
def dense_to_sparse(dense_matrix):
    """
    将稠密邻接矩阵转换为 PyG 的 edge_index 和 edge_weight。
    :param dense_matrix: 稠密邻接矩阵 (N × N, torch.Tensor)
    :return: edge_index (2 × num_edges), edge_weight (num_edges)
    """
    edge_index = torch.nonzero(dense_matrix > 0, as_tuple=False).T
    edge_weight = dense_matrix[dense_matrix > 0]
    return edge_index, edge_weight
```

#### **b) PyG 稀疏矩阵 → 稠密矩阵**
```python
def sparse_to_dense(edge_index, N):
    """
    将 PyG 的 edge_index 和 edge_weight 转换为稠密邻接矩阵。
    :param edge_index: 形状为 (2 × num_edges) 的张量
    :param N: agent 总数
    :return: 稠密邻接矩阵 (N × N)
    """
    dense_matrix = torch.zeros((N, N), dtype=torch.float32)
    for i, j in zip(edge_index[0], edge_index[1]):
        dense_matrix[i, j] = 1
    return dense_matrix
```

---

### **测试代码**

```python
# 初始化测试数据
connections = torch.tensor([[1, 2, -1], [0, -1, -1], [1, 3, 4], [-1, -1, -1], [-1, -1, -1]])
N, M = 5, 3

# 连接接口矩阵 → 稠密矩阵
dense_matrix = method2_to_dense(connections, N)
print("稠密矩阵:\n", dense_matrix)

# 稠密矩阵 → 连接接口矩阵
connections_recovered = dense_to_method2(dense_matrix, M)
print("恢复的连接接口矩阵:\n", connections_recovered)

# 连接接口矩阵 → PyG 稀疏矩阵
edge_index, edge_weight = method2_to_sparse(connections)
print("稀疏矩阵 edge_index:\n", edge_index)
print("稀疏矩阵 edge_weight:\n", edge_weight)

# PyG 稀疏矩阵 → 连接接口矩阵
connections_from_sparse = sparse_to_method2(edge_index, N, M)
print("从稀疏矩阵恢复的连接接口矩阵:\n", connections_from_sparse)

# 稠密矩阵 → 稀疏矩阵
edge_index_dense, edge_weight_dense = dense_to_sparse(dense_matrix)
print("稠密矩阵转换为稀疏矩阵 edge_index:\n", edge_index_dense)

# 稀疏矩阵 → 稠密矩阵
dense_matrix_recovered = sparse_to_dense(edge_index, N)
print("从稀疏矩阵恢复的稠密矩阵:\n", dense_matrix_recovered)
```

---

### **总结**

这些函数可以帮助你在 PyTorch 和 PyG 的矩阵格式之间灵活转换，并适应不同的计算需求：
- **稠密矩阵**适合简单的小规模计算。
- **稀疏矩阵**适合处理大规模稀疏图。
- **连接接口矩阵**在高效存储和遍历特定连接方面表现较好。

